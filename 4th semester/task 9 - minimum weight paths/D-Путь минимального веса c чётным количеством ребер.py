"""
Дан неориентированный взвешенный связный граф и несколько пар его вершин. Для каждой введённой пары вершин выведите
минимальный по весу путь, содержащий чётное количество рёбер, или -1, если такого пути нет.

Для решения задачи нужно построить вспомогательный граф, вершинами которого будут состояния (v,c), где v — номер
текущей вершины, c = 0 или 1 — текущая чётность количества рёбер в пути. Таким образом, каждому ребру (u,v) исходного
графа будет соответствовать рёбра ((u,0),(v,1)) и ((u,1),(v,0)) нового графа. После этого, на вспомогательном графе
надо с помощью алгоритма Дейкстры найти путь минимального веса из стартовой вершины с четностью 0 в конечную, с
чётностью, тоже равной 0.

Формат входных данных
На вход программе в первой строке подается два числа (через пробел): n , m

2 ≤ n ≤ 1000 - число вершин в графе
1 ≤ m ≤ 20000 - число рёбер
В следующих m строках задаются рёбра, по три числа в каждой строке - номера (из интервала от 0 до n-1) соединенных
вершин и положительный вес ребра. Дальше на вход передаётся одно число k, за ним следуют k строк по два числа, задающих
пары, между которыми необходимо найти пути.

Формат выходных данных
Для каждой заданной пары вершин выведите в отдельной строке путь между ними с чётным числом рёбер в виде списка вершин
и -1, если такого пути нет.
"""

from heapq import *


def corrected(s,t):
    d = [10**10]*2*n
    d[s] = 0
    p = [-1] * 2 * n
    queue = [(0,s)]
    used = set()
    while len(used) != len(g):
        if len(queue) == 0:
            break
        else:
            d_c,u =heappop(queue)
        if d_c == 10**10:
            break
        for v, w in g[u]:
            if d[v] > d[u] + w:
                d[v] = d[u] + w
                p[v] = u
                heappush(queue, (d[u]+w, v))
        used.add(u)
    if d[t] >= 10**10:
        return [-1]
    else:
        path = []
        u = t
        while u != -1:
            if u >= n:
                path.append(u - n)
            else:
                path.append(u)
            u = p[u]
        return path[::-1]


n, m = map(int, input().strip().split())
g = [[] for i in range(2*n)]
for edge in range(m):
    u, v, val = map(int, input().strip().split())
    g[u].append((v+n, val))
    g[v].append((u + n, val))
    g[u+n].append((v, val))
    g[v+n].append((u, val))
k = int(input())
for i in range(k):
    s,t = map(int, input().strip().split())
    print(*corrected(s, t))
